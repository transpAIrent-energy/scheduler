components:
  # ------------------- GRIDS -------------------
  
  grid_ext:
    type: Node
    carrier: electricity
  
  grid_int:
    type: Node
    carrier: electricity

  # --------------- GRID TARIFFS ----------------

  grid_con_consume_limit:
    type: Decision
    lb: 0
    ub: <bromberg_grid_p_max_consume> - <bromberg_grid_p_peak_consume>
    cost: <bromberg_grid_cost_p_consume>

  grid_con_consume:
    type: Connection
    node_from: <self>.grid_ext
    node_to: <self>.grid_int
    lb: 0
    ub: <bromberg_grid_p_peak_consume> + <self>.grid_con_consume_limit:value
    cost: <bromberg_grid_cost_e_consume>
  
  grid_con_feedin:
    type: Connection
    node_from: <self>.grid_int
    node_to: <self>.grid_ext
    lb: 0
    ub: <bromberg_grid_p_max_feedin>
    cost: <bromberg_grid_cost_e_feedin>

  # -------------------- PV ---------------------

  pv:
    type: Profile
    carrier: electricity
    node_to: <self>.grid_int
    value: pv_s@data + pv_l@data
  
  # NOTE: `pv_***@data` can contain negative values (consumption), which is why we need to limit the remaining
  #       `ub` using `max(0, ...)` to prevent infeasible models as soon as `ub = pv_***@@data < 0 = lb`.
  pv_curtailment:
    type: Profile
    carrier: electricity
    node_from: <self>.grid_int
    mode: ranged
    lb: 0
    ub: <pv_curtailment_factor> * max(0, pv_s@data + pv_l@data)
  
  # ------------------ DEMAND -------------------

  demand_total:
    type: Profile
    carrier: electricity
    node_from: <self>.grid_int
    value: demand_bromberg_s@data + demand_bromberg_l@data

  # ------------------ BATTERY ------------------

  battery_storage:
    type: Node
    carrier: electricity
    has_state: true
    state_lb: <battery_soc_min> * <battery_e>
    state_ub: <battery_soc_max> * <battery_e>
    state_percentage_loss: <battery_loss>
    state_cyclic: geq
    state_initial: <battery_soc_t0> * <battery_e>
  
  battery_charging:
    type: Unit
    inputs: {electricity: <self>.grid_int}
    outputs: {electricity: <self>.battery_storage}
    conversion: 1 electricity -> sqrt(<battery_eta>) electricity
    marginal_cost: (<battery_vom> / 2.0) per in:electricity
    capacity: <battery_p> in:electricity

  battery_discharging:
    type: Unit
    inputs: {electricity: <self>.battery_storage}
    outputs: {electricity: <self>.grid_int}
    conversion: 1.0 / sqrt(<battery_eta>) electricity -> 1 electricity
    marginal_cost: (<battery_vom> / 2.0) per out:electricity
    capacity: <battery_p> out:electricity

  # ---------------- FEASIBILITY ----------------
  
  feasibility_create:
    type: Profile
    carrier: electricity
    node_to: <self>.grid_int
    mode: create
    cost: 100.0

  feasibility_destroy:
    type: Profile
    carrier: electricity
    node_from: <self>.grid_int
    mode: destroy
    cost: 100.0
